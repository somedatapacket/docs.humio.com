[{"aliases":[],"name":"sum","examples":[{"description":"How many bytes did our webserver send per minute","value":"bucket(function=sum(bytes_send))"}],"description":"Calculates the sum for a field over a set of events. Result is returned in a field named _sum","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"field to extract a number from and sum over\"","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_sum"}],"defaultParameter":"field"},{"aliases":[],"name":"stdDev","examples":[{"description":"Find the standard deviation of bytes send in http responses","value":"stdDevBytes := stdDev(field=bytes_send)"}],"description":"Calculates the standard deviation for a field over a set of events. Result is returned in field named _stddev","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"field to extract a number from and calculate standard deviation over","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_stddev"}],"defaultParameter":"field"},{"aliases":[],"name":"ipLocation","examples":[],"description":"Determine country, city, and long/latitude for an IP address (ipv4 or ipv6).  The attributes ip.country, ip.city, ip.lon, ip.lat are added to the event.\n\nIn order to use your own GeoLite2 database, place a copy of GeoLite2-City.mmdb in the humio-data directory.\n\nThis product includes GeoLite2 data created by MaxMind, available from [http://www.maxmind.com](http://www.maxmind.com)\n","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"The field from which to get the IP address","isUnnamed":true,"type":"string","defaultValue":"ip"},{"name":"as","isRequired":false,"description":"Name the prefix to add to fields added by the ipLocation function.  Defaults to '<ip-address-field>.' (the name of the field from which to get the IP address).","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"in","examples":[{"description":"Filter by Log Level","value":"in(loglevel, values=[\"ERROR\", \"WARN\"])"}],"description":"Filter records by values where `field` is in `values`.","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The field to filter records by.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"values","isRequired":true,"description":"The values for to match the field against. A field which any of these values will pass through. Values can contain * wildcards.","isUnnamed":false,"type":"[string]","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"tail","examples":[{"description":"Select the 10 newest with loglevel=ERROR","value":"loglevel=ERROR | tail(10)"},{"description":"Select the 100 latest events and group them by loglevel","value":"tail(limit=100) | groupby(loglevel)"}],"description":"Returns the newest events.","isAggregateFunction":true,"parameters":[{"name":"limit","isRequired":false,"description":"The maximum number of events to return. The maximum allowed is 10000.","isUnnamed":true,"type":"number","defaultValue":"200"}],"defaultParameter":"limit"},{"aliases":[],"name":"lowercase","examples":[{"description":"With an event with a field \"Bar=CONTENTS\", you get 'contents' in the 'Bar' field","value":"lowercase(\"Bar\")"},{"description":"With an event with a field \"BAR=CONTENTS\", you get 'CONTENTS' in the 'bar' field, while BAR is still CONTENTS.","value":"lowercase(\"BaR\", include=\"field\")"},{"description":"With an event with a field \"BAR=CONTENTS\", you get 'contents' in the 'bar' field, while BAR is still CONTENTS.","value":"lowercase(field=[\"foo\",\"bar\"], include=\"both\")"}],"description":"Lowercases the contents of a string field, replacing the value in the input fields.","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The name of the input field or fields (in []) to lowercase.","isUnnamed":true,"type":"[string]","defaultValue":null},{"name":"locale","isRequired":false,"description":"The name of the locale to use, as ISO 639 language and an optional ISO 3166 country, such as 'da','da_DK' or 'en_US'. When not specified, uses the system locale","isUnnamed":false,"type":"string","defaultValue":null},{"name":"include","isRequired":false,"description":"What to lowercase. One of ('values', 'fields', 'both'). Defaults to 'values'. If set to 'fields' or 'both', then the 'field' names are matched against event fields non-case-sensitive, the matching fields names are lower-cased, and the resulting key-value pair added to the event, with the value being lower-cased only for 'both'.","isUnnamed":false,"type":"string","defaultValue":"values"}],"defaultParameter":"field"},{"aliases":[],"name":"percentile","examples":[{"description":"Calculate 50 75 99 and 99.9 percentiles for events with the field responsetime.\n","value":"percentile(field=responsetime, percentiles=[50, 75, 99, 99.9])"},{"description":"In a timechart, calculate percentiles for both of the fields r1 and r2.\n","value":"timechart(function=[percentile(field=r1,as=r1),percentile(field=r2,as=r2)])"}],"description":"calculates percentiles over numbers.<br/>\nreturns one event with a field for each of the percentiles specified in the percentiles parameter. Fields are named like by appending _ to the values specified in the percentiles parameter.\nFor example the event could contain the fields _50, _75 and _99.\n      ","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"Specifies the field for which to calculate percentiles. The field must contain numbers","isUnnamed":true,"type":"string","defaultValue":null},{"name":"percentiles","isRequired":false,"description":"Specifies which percentiles to calculate. An example is [50, 75, 99]","isUnnamed":false,"type":"[number]","defaultValue":"[50, 75, 99]"},{"name":"as","isRequired":false,"description":"prefix of output fields","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"regex","examples":[{"description":"extract the domain name of the http referrer field. Often this field contains a full url, so we can have many different URLs from the same site.\nIn this case we want to count all referrels from the same domain. this will add a field named refdomain to events matching the regular expression","value":"regex(\"https?://(www.)?(?<refdomain>.+?)(/|$)\", field=referrer) | groupby(refdomain, function=count()) | sort(field=_count, type=number, reverse=true)"},{"description":"extract the userid from the url field. New fields is stored in a field named userid","value":"regex(regex=\".*/user/(?<userid>\\S+)/pay\", field=url)"},{"description":"Shows how to escape \" in the regular expression. This is necessary because the regular expresssion is itself in quotes. Extract the user and message from events like: 'Peter: \"hello\"' and 'Bob: \"good morning\"'","value":"regex(\"(?<name>\\S+): \\\"(?<msg>\\S+)\\\"\")"}],"description":"Extract new fields using a regular expression. The regular expression can contain one or more named capturing groups. Fields with the names of the groups will be added to the events.\nUsing \" in already quoted strings requires escaping. This is sometimes necessary when writing regular expressions. see example 3.  \nHumio uses [re2j](https://github.com/google/re2j) regular expressions, which has a syntax very close to Java's regular expressions. Check out the [syntax here](https://github.com/google/re2/wiki/Syntax). \n      ","isAggregateFunction":false,"parameters":[{"name":"regex","isRequired":true,"description":"Specifies a regular expression. The regular expression can contain one or more named capturing groups. Fields with the names of the groups will be added to the events.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"field","isRequired":false,"description":"Specifies the field to run the regular expression against. Default is running against @rawstring","isUnnamed":false,"type":"string","defaultValue":"@rawstring"},{"name":"strict","isRequired":false,"description":"specifies if events not matching the regular expression should be filtered out of the result set. Strict is the default","isUnnamed":false,"type":"bool","defaultValue":"true"},{"name":"flags","isRequired":false,"description":"specifies other regex flags \"m\" is multi-line, \"i\" is ignore_case, \"d\" is dotall i.e., dot includes newline","isUnnamed":false,"type":"string","defaultValue":"m"},{"name":"repeat","isRequired":false,"description":"If set to true, multiple matches yields multiple events","isUnnamed":false,"type":"bool","defaultValue":"false"}],"defaultParameter":"regex"},{"aliases":[],"name":"max","examples":[{"description":"What was the maximum responsetime","value":"max(responsetime)"}],"description":"Finds the biggest number for the specified field over a set of events. Result is returned in a field named _max","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"field to extract a number from","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_max"}],"defaultParameter":"field"},{"aliases":[],"name":"count","examples":[{"description":"Count the number of events in the search time period","value":"count()"},{"description":"Count the number of http method requests(GET, PUT, POST etc) ","value":"groupby(field=http_method, function=count())"},{"description":"Count the number of http method requests(GET, PUT, POST etc) over time","value":"timechart(function=count())"},{"description":"Count all events containing the field statuscode","value":"count(field=statuscode)"},{"description":"Count unique values. Count the number of different statuscodes","value":"count(statuscode, distinct=true)"}],"description":"Counts events streaming through the function. Result is put in a field named _count\nIt is possible to specify a field, and only events containing that field is counted.\nIt is also possible to do a distinct count. When having many distinct values Humio will not try to keep them all in memory. Estimation is then used and the result will not be a precise match.","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":false,"description":"Only events with this field is counted","isUnnamed":true,"type":"string","defaultValue":null},{"name":"distinct","isRequired":false,"description":"count distinct values. When having many distinct values Humio uses estimation and the result is not excact.","isUnnamed":false,"type":"bool","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_count"}],"defaultParameter":"field"},{"aliases":[],"name":"parseTimestamp","examples":[{"description":"Events having a timestamp in ISO8601 format can be parsed using the default format.\n\n An example is a timestamp like `2017-12-18T20:39:35Z server is starting. binding port=8080`","value":"/(?<timestamp>\\S+)/ | parseTimestamp(field=timestamp)"},{"description":"Parse timestamps in an accesslog with timestamps like `192.168.1.19 [02/Apr/2014:16:29:32 +0200] GET /hello/test/123 ...`","value":"/(?<client>\\S+) \\[(?<@timestamp>.+)\\] (?<method>\\S+) (?<url>\\S+)/ | parseTimestamp(\"dd/MMM/yyyy:HH:mm:ss Z\", field=timestamp)"},{"description":"Parse a timestamp without a timezone like `2015-12-18T20:39:35`","value":"parseTimestamp(\"yyyy-MM-dd'T'HH:mm:ss\", field=timestamp, timezone=\"America/New_York\")"},{"description":"Parse an event with a timestamp not containing year like `Feb  9 12:22:44 hello world`","value":"/(?<timestamp>\\S+\\s+\\S+\\s+\\S+)/ | parseTimestamp(\"MM [ ]d HH:mm:ss\", timezone=\"Europe/London\")"}],"description":"\nParse a string into a timestamp.\n\nThis function is important for creating parsers, as it is used to parse the timestamp for an incoming event.\n\nBefore parsing the timestamp, the part of the log containing the timestamp should be captured into a field.  \nThis is done using functions like [`regex()`](#regex) and [`parseJson()`](#parseJson) before `parseTimestamp`.\n \nThe format string is specified using [Javas DateTimeFormatter](https://docs.oracle.com/javase/9/docs/api/java/time/format/DateTimeFormatter.html). Humio also supports specifying the following in the format string:\n\n* `unixtimeMillis` UTC time since 1970 in milliseconds\n* `unixtime` UTC time since 1970 in seconds\n\nIf the timestamp is parsed it will create a field '@timestamp' containing the parsed timestamp in UTC milliseconds \nand a `@timezone` field containing the original timezone.\n\nIt is possible to parse time formats leaving out the year designator as is sometime seen in time formats from Syslog.\n  For example Mar 15 07:48:13 can be parsed using the formtat `MM d HH:mm:ss`. In this case Humio will guess the year.\n\n      ","isAggregateFunction":false,"parameters":[{"name":"format","isRequired":false,"description":"Pattern used to parse the timestamp. Default value will parse an ISO 8601 date using the format string `yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX`. The format string is specified using [Javas DateTimeFormatter](https://docs.oracle.com/javase/9/docs/api/java/time/format/DateTimeFormatter.html) ","isUnnamed":true,"type":"string","defaultValue":"yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX"},{"name":"field","isRequired":false,"description":"The field holding the timestamp to be parsed","isUnnamed":false,"type":"string","defaultValue":"timestamp"},{"name":"timezone","isRequired":false,"description":"If the timestamp does not contain a timezone, it can be specified using this parameter. A list of the available timezones can be found [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). Example are `Europe/London`, `America/New_York` and `UTC`","isUnnamed":false,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"Name of output field that will contain the parsed timestamp. The timestamp is represented as milliseconds since 1970 in UTC. Humio expects to find the timestamp in the field `@timestamp`, so do not change this when creating parsers.","isUnnamed":false,"type":"string","defaultValue":"@timestamp"},{"name":"timezoneAs","isRequired":false,"description":"Name of output field that will contain the parsed timezone. Humio expects to ind the timezone in the field `@timezone`, so do not change when creating parsers","isUnnamed":false,"type":"string","defaultValue":"@timezone"},{"name":"nowIfNone","isRequired":false,"description":"set timestamp to now if it does not exist or cannot be parsed","isUnnamed":false,"type":"bool","defaultValue":"true"}],"defaultParameter":"format"},{"aliases":[],"name":"splitString","examples":[{"description":"Assuming an event has the @rawstring \"2007-01-01 test bar\" you can split the string into attributes `part[0]`, `part[1]`, and `part[2]`","value":" ... | part := splitString(field=@rawstring, by=\" \")"},{"description":"Assuming an event has the @rawstring \"2007-01-01 test bar\" you can split pick out the date part using","value":" ... | date := splitString(field=@rawstring, by=\" \", index=0)"}],"description":"Split a string by specifying a regular expression to split by","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"Field that needs splitting","isUnnamed":true,"type":"string","defaultValue":"@rawstring"},{"name":"by","isRequired":true,"description":"String/regex to split by","isUnnamed":false,"type":"string","defaultValue":null},{"name":"index","isRequired":false,"description":"Emit only this index after splitting","isUnnamed":false,"type":"number","defaultValue":null},{"name":"as","isRequired":false,"description":"Emit selected attribute using this name","isUnnamed":false,"type":"string","defaultValue":"_splitstring"}],"defaultParameter":"field"},{"aliases":["strftime"],"name":"formatTime","examples":[{"description":"format time","value":"time := formatTime(\"%Y/%m/%d %H:%M:%S\", field=@timestamp, locale=en_US, timezone=Z)"}],"description":"Formats a string according to strftime,\nsimilar to unix [strftime(3)](https://www.freebsd.org/cgi/man.cgi?query=strftime&sektion=3)","isAggregateFunction":false,"parameters":[{"name":"format","isRequired":true,"description":"Format string. See Java docs for [valid Date/Time valid escapes](https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#dt).","isUnnamed":true,"type":"string","defaultValue":null},{"name":"field","isRequired":false,"description":"where to get the current time","isUnnamed":false,"type":"string","defaultValue":"@timestamp"},{"name":"as","isRequired":true,"description":"Specifies the output field","isUnnamed":false,"type":"string","defaultValue":null},{"name":"locale","isRequired":false,"description":"Specifies the locale such as US or en_GB","isUnnamed":false,"type":"string","defaultValue":null},{"name":"timezone","isRequired":false,"description":"Specifies the timezone such as GMT or EST","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"format"},{"aliases":[],"name":"stats","examples":[{"description":"This is equivalent to just `count()`","value":"stats(function=count())"},{"description":"find the maximum and minimum","value":"[min_response := min(responsetime), max_response := max(responsetime)]"}],"description":"Used to compute multiple aggregate functions over the input.  `... | stats(function=[min(), max()])` -- equivalent to just `[min(), max()]`.  It produces *one*\n row of data that contains both `min` and `max` results.\n      ","isAggregateFunction":true,"parameters":[{"name":"function","isRequired":false,"description":"Specifies which aggregate functions to perform on each group. Default is to count(as=_count) the elements","isUnnamed":true,"type":"[Aggregate]","defaultValue":"count(as=_count)"}],"defaultParameter":"function"},{"aliases":[],"name":"format","examples":[{"description":"format a float to have 2 decimals","value":"format(\"%.2f\", field=price, as=price) | table(price)"},{"description":"Concatenate 2 fields with a comma as separator","value":"format(format=\"%s,%s\", field=[a, b], as=\"combined\") | table(combined)"},{"description":"Get the hour of day out of the events @timestamp","value":"format(\"%tm\", field=@timestamp, as=hour) | table(hour)"}],"description":"Format a string using printf-style.  \nThe formatted string is put in a new field named by the `as` parameter (default is `_format`).\nThe fields used as input parameters to the formatting are named using the `field` parameter, which can be an array.  \nThis function is backed by Java's [Formatter class](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html).  \nFor detailed documentation follow the link.  \nAt the moment fields can only be used as datetime values if they are in iso 8601 format of if they are Milliseconds since the beginning of the epoch starting at 1 January 1970 00:00:00 UTC. \n","isAggregateFunction":false,"parameters":[{"name":"format","isRequired":true,"description":"The formatter string. [See the Java documentation](https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html)","isUnnamed":true,"type":"string","defaultValue":null},{"name":"field","isRequired":true,"description":"Fields to insert into the formatter string. This is the field names on events (not an actual value","isUnnamed":false,"type":"[string]","defaultValue":null},{"name":"as","isRequired":false,"description":"The output name of the field with the formatted string)","isUnnamed":false,"type":"string","defaultValue":"_format"},{"name":"timezone","isRequired":false,"description":"When formatting dates and times it is possible to specify a timezone. Examples: `Europe/Copenhagen`, `UTC`, `America/New_York`, `+01`","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"format"},{"aliases":[],"name":"subnet","examples":[{"description":"compute subnet for 'ipAddress' using 23bit prefix; emit into subnet field","value":"subnet(ipAddress, bits=23, as=subnet)"}],"description":"Compute a subnet from a ipv4 field; by default emits a into a _subnet field.\n\n      ","isAggregateFunction":false,"parameters":[{"name":"bits","isRequired":true,"description":"Specifies the output field (defaults to _subnet.)","isUnnamed":false,"type":"number","defaultValue":null},{"name":"as","isRequired":false,"description":"Specifies the prefix bits to include in the subnet, e.g. 23.","isUnnamed":false,"type":"string","defaultValue":"_subnet"},{"name":"field","isRequired":true,"description":"Specifies the input field.","isUnnamed":true,"type":"string","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"match","examples":[{"description":"matches events for which the 'id' field matches the value of 'userid' in the table \"users.csv\".","value":"match(file=\"users.csv\", column=userid, field=id, include=[])"},{"description":"matches events for which the 'id' field matches the value of 'userid' in the table \"users.csv\", and add all other columns of the matching row to those events.","value":"id =~ match(file=\"users.csv\", column=userid)"}],"description":"Search using a CSV or JSON file and enrich entries.\n\nTo use this function, you need to upload a CSV or JSON file using the [lookup api](https://docs.humio.com/api/lookup-api).\n\nYou can use it to do something like `field IN xxx`, where `xxx` is really all the values in a `column=Name` in the CSV `file=File.CSV` you specify.\n\nThe default behavior (when `struct=true`) this function works like an 'INNER JOIN'.  With `strict=false`, this function works like the deprecated `lookup`\nfunction, i.e., it just enriches events that match, but let all events pass through even if they don't match.\n\n      ","isAggregateFunction":false,"parameters":[{"name":"file","isRequired":true,"description":"Specifies the source file.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"strict","isRequired":false,"description":"If true (default) only yield events that match a key in the file; if false let all events through (works like the function 'lookup').","isUnnamed":false,"type":"bool","defaultValue":"true"},{"name":"include","isRequired":false,"description":"Specifies columns to include. If no argument given, include all columns from the corresponding row in the output event","isUnnamed":false,"type":"[string]","defaultValue":null},{"name":"column","isRequired":false,"description":"specifies which column in the file to use for the match.  Defaults to the value of the 'field' parameter.","isUnnamed":false,"type":"string","defaultValue":null},{"name":"field","isRequired":true,"description":"specifies which field in the event (log line) that must match the given column value","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"file"},{"aliases":[],"name":"min","examples":[{"description":"What was the minimum responsetime","value":"min(responsetime)"}],"description":"Finds the smallest number for the specified field over a set of events. Result is returned in a field named _min","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"field to extract a number from","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_min"}],"defaultParameter":"field"},{"aliases":[],"name":"holtwinters","examples":[{"description":"Show event count graph with dayly aggregates and compute the weekly trend.","value":"timechart(function=count(), span=1d) | holtwinters(period=7d)"}],"description":"Used to generate a trendline for a periodic dataset. The key parameter  period specifies the length of the period to be applied.  This is used after a timechart, as in `timechart(...) | holtwinters(1week)`. The function implements [triple exponential smoothing](https://en.wikipedia.org/wiki/Exponential_smoothing#Triple_exponential_smoothing), and adds an extra graph for every series in the graph.  The computation assumes periodic data set (the period parameter specifies the  length of the period), such as daily or weekly traffic measurements.  The function works best when the timechart's span (with of each bucket) is a multiple of the period, as the smoothing is done in  units of the buckets. \n\n  For example, a 30 day chart with a 7 day period would have 4 periods from day 2 to 30 (the first 2 days being ignored). Based on this, the first 3 periods (in this case period 1, 2 and 3) are fed into the smoothing/forecast computation, producing a \"forecast\" for the fourth period.  Smoothing data for period 2, 3 and 4 are emitted, the last period being entirely computed. ","isAggregateFunction":false,"parameters":[{"name":"period","isRequired":true,"description":"Defines the trend's period, such as 1week or 1day","isUnnamed":true,"type":"string","defaultValue":null},{"name":"alpha","isRequired":false,"description":"data smoothing factor in the interval [0..1]","isUnnamed":false,"type":"number","defaultValue":"0.5"},{"name":"beta","isRequired":false,"description":"trend smoothing factor in the interval [0..1]","isUnnamed":false,"type":"number","defaultValue":"0"},{"name":"gamma","isRequired":false,"description":"seasonal change smoothing in the interval [0..1]","isUnnamed":false,"type":"number","defaultValue":"0"}],"defaultParameter":"period"},{"aliases":[],"name":"parseUrl","examples":[{"description":"Parses the field named url and adds URL components to the event.","value":"parseUrl()"},{"description":"Parses the field named endpoint and adds URL components to the event.","value":"parseUrl(field=endpoint)"},{"description":"Parses the field named endpoint and adds URL components to the event with url as a prefix.","value":"url := parseUrl(field=endpoint)"},{"description":"Parses the field named endpoint and adds URL components to the event with apiEndpoint as a prefix.","value":"parseUrl(field=endpoint, as=apiEndpoint)"}],"description":"Extracts URL components from a field. The attributes url.scheme, url.username, url.password, url.host, url.port, url.path, url.fragment and url.query are added to the event","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"The field from which to parse URL components.","isUnnamed":true,"type":"string","defaultValue":"url"},{"name":"as","isRequired":false,"description":"Use a prefix for the attributes added to the event.","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"kvParse","examples":[{"description":"Key-value parse the log line: `creating new user id=123, name='john doe' email=john@doe`.\nThis will add the fields `id=123`, `name=john doe' and `email=john@doe` to the event. ","value":"kvParse()"},{"description":"Key value parse a nested field. In this example we will use JSON input: \n`{\"service\": \"paymentService\", \"type\": \"payment\", \"metadata\":\"host=server5,transactionID=123,processingTime=100\"}`\n and parse out the key-values in the metadata field\n","value":"parseJSON() | kvParse(metadata)"}],"description":"\nKey-value parse events. This function can run an extra key-value parser on events. It is used to parse key-values of the form:\n \n * `key=value`\n * `key=\"value\"`\n * `key='value'`\n\nSo for a log line like this:\n\n`2017-02-22T13:14:01.917+0000 [main thread] INFO  UserService -  creating new user id=123, name='john doe' email=john@doe`\n\n The key-value parser extracts the fields:\n\n * `id: 123`\n * `name: john doe`\n * `email: john@doe`\n \n \n Use the `field` parameter to specify which fields should be key-value parsed. Specify `@rawstring` to key-value parse the rawstring\n \n    ","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"Fields that should be key-value parsed","isUnnamed":true,"type":"[string]","defaultValue":"@rawstring"}],"defaultParameter":"field"},{"aliases":[],"name":"concat","examples":[{"description":"Concatenates the values of the fields f1 and f2 from each event into the field combined.\n","value":"concat([f1, f2], as=\"combined\")"}],"description":"Concatenates the values of a list of fields into a value in a new field\n","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"Fields to concatenate","isUnnamed":true,"type":"[string]","defaultValue":null},{"name":"as","isRequired":false,"description":"The output name of the field to set (defaults to _concat)","isUnnamed":false,"type":"string","defaultValue":"_concat"}],"defaultParameter":"field"},{"aliases":[],"name":"rename","examples":[{"description":"rename 'badName' to 'goodName'","value":" rename(field=badName, as=goodName) "},{"description":"rename 'badName' to 'goodName', using assignment syntax","value":"goodName := rename(badName) "}],"description":"","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The field name to remove","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":true,"description":"The new name of the field","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"avg","examples":[{"description":"Find the average bytes send in http responses","value":"avg(field=bytes_send)"}],"description":"Calculates the average for a field over a set of events. Result is returned in field named _avg","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"field to extract a number from and calculate average over","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_avg"}],"defaultParameter":"field"},{"aliases":[],"name":"groupBy","examples":[{"description":"Count different http status codes","value":"groupBy(field=status_code, function=count())"},{"description":"group by http method and http statuscode and count the events in each group","value":"groupBy(field=[method, status_code], function=count())"},{"description":"Find the maximum response time for each device","value":"groupBy(field=device, function=max(responsetime, as=time)) | sort(time)"}],"description":"Like groupby in sql. Groups events by specified fields and executes aggregate functions on each group.<br/>\nReturns events containing the fields specified in the field parameter and the fields returned by each aggregate function. For example a _count field if function=count()<br/>\nWhen showing time series data the timechart and bucket functions are an extension of group by that groups by time. Look at <code>timechart</code> and <code>bucket</code>.<br/>\nGroupby limits the number of groups to 20000. After that no more groups will be created.  In that case see if the *top* function is a better match.\nIt is on the roadmap to remove this limitation. At the moment groupby is implemented to work entirely in memeory and cannot spill to disk.\n      ","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"specifies which fields to group by. Note it is possible to group by multiple fields.","isUnnamed":true,"type":"[string]","defaultValue":null},{"name":"function","isRequired":false,"description":"Specifies which aggregate functions to perform on each group. Default is to count(as=_count) the elements in each group","isUnnamed":false,"type":"[Aggregate]","defaultValue":"count(as=_count)"},{"name":"limit","isRequired":false,"description":"limit for the number of group elements [0..âˆž]. Only allowed above 20000 if Humio is configured with ALLOW_UNLIMITED_STATE_SIZE=true by the operator. So default is limit=20000","isUnnamed":false,"type":"string","defaultValue":null}],"defaultParameter":"field"},{"aliases":["to_radix_10"],"name":"parseInt","examples":[{"description":"Shows how to parse a hexadecimal string in little endian as an integer.\nAn input event with the field \"hexval\" with the value \"8001\" results in the field \"centigrades\" having the value (1*256)+128=384.\n","value":"parseInt(hexval, as=\"centigrades\", radix=\"16\", endian=\"little\")"},{"description":"Shows how to parse a hexadecimal string in big endian as an integer.\nAn input event with the field \"hexval\" with the value \"8001\" results in the field \"centigrades\" having the value (128*256)+1=32769.\n","value":"parseInt(hexval, as=\"centigrades\", radix=\"16\", endian=\"little\")"},{"description":"Shows how to parse a binary string as an integer.\nAn input event with the field \"bitval\" with the value \"00011001\" results in the field \"flags\" having the value 16+8+1=25.\n","value":"parseInt(bitval, as=\"flags\", radix=\"2\")"}],"description":"Converts an integer from any radix (or base), such as from hexadecimal or octal, to base=10, the decimal radix, expected as input by all other functions.\nE.g. converting \"FF\" to \"255\" using radix=16 or \"77\" to \"63\" using radix=8.\nThe conversion is always unsigned.<br/>\nIf the input fields has a prefix (other than \"0x\" and \"16#\") then use [regex](https://docs.humio.com/query-functions#regex) to remove the prefix before using parseInt.\n","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The name of the input field.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"The output name of the field to set (defaults to the same as the input field)","isUnnamed":false,"type":"string","defaultValue":null},{"name":"radix","isRequired":false,"description":"Input Integer base (2 to 36).","isUnnamed":false,"type":"number","defaultValue":"16"},{"name":"endian","isRequired":false,"description":"Input Digit-pair ordering (little, big) for hexadecimal.","isUnnamed":false,"type":"string","defaultValue":"big"}],"defaultParameter":"field"},{"aliases":[],"name":"head","examples":[{"description":"Select the 10 oldest with loglevel=ERROR","value":"loglevel=ERROR | head(10)"},{"description":"Select the 100 oldest events and group them by loglevel","value":"head(limit=100) | groupby(loglevel)"}],"description":"Returns the oldest events.","isAggregateFunction":true,"parameters":[{"name":"limit","isRequired":false,"description":"The maximum number of events to return. The maximum allowed is 10000.","isUnnamed":true,"type":"number","defaultValue":"200"}],"defaultParameter":"limit"},{"aliases":[],"name":"bucket","examples":[{"description":"Divides the search time interval into buckets. As time span is not specified, the search interval id divided into 127 buckets. Events in each bucket are counted","value":"bucket(function=count())"},{"description":"Count different http status codes over time. Bucket them into time intervals of 1 minute. Notice we group by 2 fields status code and the implicit _bucket","value":"bucket(1min, field=status_code, function=count())"},{"description":"Show response time percentiles over time. Calculate percentiles per minute (bucket time into 1 minute intervals)","value":"bucket(span=60sec, function=percentile(field=responsetime, percentiles=[50, 75, 99, 99.9]))"}],"description":"Bucket is an extension of the <code>groupby</code> function for grouping by time. Look at <code>timechart</code> before using this function.\nThis function divides the search time interval into buckets. Each event is put into a bucket based on its timestamp.<br>\nEvents are grouped by their bucket. Which is a field named _bucket\n. The value is the buckets start time in milliseconds (UTC time).<br>\nBucket takes all the same parameters as <code>groupby</code>. The _bucket\n is added to the fields grouped by.\n","isAggregateFunction":true,"parameters":[{"name":"limit","isRequired":false,"description":"Defines the maximum number of series to produce (defaults to 20). A warning is produced if this limit is exceeded, unless the parameter is specified explicitly.","isUnnamed":false,"type":"number","defaultValue":null},{"name":"timezone","isRequired":false,"description":"Defines the time span for each bucket. The time span is defined as a [relative time modifier](https://docs.humio.com/appendix/relative-time-syntax) like 1hour or \"3 weeks\". If not provided the search time interval is divided into 127 buckets","isUnnamed":false,"type":"string","defaultValue":null},{"name":"span","isRequired":false,"description":"Defines the time span for each bucket. The time span is defined as a [relative time modifier](https://docs.humio.com/appendix/relative-time-syntax) like 1hour or \"3 weeks\". If not provided the search time interval is divided into 127 buckets","isUnnamed":true,"type":"string","defaultValue":null},{"name":"buckets","isRequired":false,"description":"Defines the the number of buckets. The time span is defined by splitting the query time interval into this many buckets. 0..1500","isUnnamed":false,"type":"number","defaultValue":null},{"name":"field","isRequired":false,"description":"specifies which fields to group by. Note it is possible to group by multiple fields.","isUnnamed":false,"type":"[string]","defaultValue":null},{"name":"function","isRequired":false,"description":"Specifies which aggregate functions to perform on each group. Default is to count(as=_count) the elements in each group","isUnnamed":false,"type":"[Aggregate]","defaultValue":"count(as=_count)"}],"defaultParameter":"span"},{"aliases":[],"name":"select","examples":[],"description":"Specify a set of fields to select from each event. You most likely want to use the `table` function instead. Table is an aggregate function that can also sort events.","isAggregateFunction":false,"parameters":[{"name":"fields","isRequired":true,"description":"The names of the fields to keep.","isUnnamed":true,"type":"[string]","defaultValue":null}],"defaultParameter":"fields"},{"aliases":[],"name":"lookup","examples":[{"description":"lookup rows from table \"users.csv\" where the 'userid' column equals the 'id' field of this event","value":"lookup(\"users.csv\", on=[userid,id])"}],"description":"Enrich events with metadata. Data can be uploaded as CSV or JSON files using the [files](https://docs.humio.com/api/lookup-api) endpoint.\n      ","isAggregateFunction":false,"parameters":[{"name":"from","isRequired":true,"description":"Specifies the source file.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"include","isRequired":false,"description":"Specifies fields to include, defaults to all","isUnnamed":false,"type":"[string]","defaultValue":null},{"name":"on","isRequired":true,"description":"specifies which field(s) to join on; if passed as array the first is the field from the file, the second is from the event","isUnnamed":false,"type":"[string]","defaultValue":null}],"defaultParameter":"from"},{"aliases":[],"name":"replace","examples":[{"description":"Correct a spelling mistake","value":"replace(regex=rpoperties, with=properties)"},{"description":"Get the integer part of a number. This example uses regex capturing groups","value":"replace(\"(\\d+)\\..*\", with=\"$1\", field=a)"}],"description":"Replaces each substring of the specified fields value that matches the given regular expression with the given replacement.  \nHumio uses [re2j](https://github.com/google/re2j) regular expressions, which has a syntax very close to Java's regular expressions. Check out the [syntax here](https://github.com/google/re2/wiki/Syntax).\n","isAggregateFunction":false,"parameters":[{"name":"regex","isRequired":true,"description":"The regular expression to match","isUnnamed":true,"type":"string","defaultValue":null},{"name":"with","isRequired":false,"description":"The string to substitute for each match (defaults to \"\")","isUnnamed":false,"type":"string","defaultValue":null},{"name":"replacement","isRequired":false,"description":"The string to substitute for each match (same as with)","isUnnamed":false,"type":"string","defaultValue":null},{"name":"field","isRequired":false,"description":"Specifies the field to run the replacement on. Default is running against @rawstring","isUnnamed":false,"type":"string","defaultValue":"@rawstring"}],"defaultParameter":"regex"},{"aliases":[],"name":"collect","examples":[{"description":"collect visitors (each visitor defined as non-active after 1 minute)","value":"groupby(client_ip, function=session(maxpause=1m, collect([url])))"}],"description":"Collect fields from multiple events into *one* event.","isAggregateFunction":true,"parameters":[{"name":"multival","isRequired":false,"description":"Collect resulting value as multivalue","isUnnamed":false,"type":"bool","defaultValue":"true"},{"name":"fields","isRequired":false,"description":"The names of the fields to keep.","isUnnamed":true,"type":"[string]","defaultValue":null},{"name":"maxlen","isRequired":false,"description":"the maximum length of the generated @rawstring.","isUnnamed":false,"type":"number","defaultValue":"2000"}],"defaultParameter":"fields"},{"aliases":[],"name":"counterAsRate","examples":[{"description":"Show the rate of a counter over time","value":"timechart(function=counterasrate(counter))"}],"description":"Calculates the rate for a counter field. This function can show the rate at which a counter changes. The result is returned in a field named <code>_rate</code>.<br/>\n<code>counterAsRate</code> is often expected to be used as the function in a <code>timechart</code> (or <code>groupby</code>).\nNOTE this function requires at least to two points for calculating a rate. ** When used in a timechart, it is important to have at least two points in each bucket to get a rate.**<br/>\nThis function expects the field to have monotonic increasing values over time. If this is not the case no result is returned. \nCounters are often reset at server restarts or deployments. Running Rate over a reset, would not return a result.\nUsing <code>counterAsRate</code> in a <code>timechart</code> returns a rate for each buckets where the counter was not reset and nothing for the buckets where the server was reset\n       ","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"field to extract a number from and calculate rate over","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_rate"}],"defaultParameter":"field"},{"aliases":[],"name":"round","examples":[{"description":"Round a number","value":"round(myvalue)"},{"description":"Round a number","value":"timechart(function=max(value)) | round(_max, how=floor)"}],"description":"Rounds an input field how=round (default), how=floor or how=ceil.","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The names of the field to round.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"The output name of the field to round (defaults to the same as the input field)","isUnnamed":false,"type":"string","defaultValue":null},{"name":"how","isRequired":false,"description":"how to round (round, ceil, floor).","isUnnamed":false,"type":"string","defaultValue":"round"}],"defaultParameter":"field"},{"aliases":[],"name":"split","examples":[{"description":"In GitHub events, a PushEvent contains an array of commits, and each commit which gets expanded into subattributes of payload.commit_0, payload.commit_1, .... Humio cannot sum/count, etc across such attributes.  Expands each PushEvent into one PushEvent for each commit so they can be counted.","value":"type=PushEvent | split(payload.commits) | groupby(payload.commits.author.email) | sort()"}],"description":"Split an event structure created by json array into distinct events. When Humio ingests JSON arrays, each array entry is turned into a separate attribute named [0], [1], ...  This function takes such an event and splits it into muliple events based on the prefix of such [N] attributes, allowing for aggregate functions across array values.  It is not very efficient, so it should only be used after some agressive filtering.","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"Field to split by","isUnnamed":true,"type":"string","defaultValue":"_events"},{"name":"strip","isRequired":false,"description":"Strip the field prefix when splitting (default is false)","isUnnamed":false,"type":"bool","defaultValue":"false"}],"defaultParameter":"field"},{"aliases":[],"name":"sample","examples":[{"description":"Sample events keeping only 2% of the events","value":"sample(percentage=2)"},{"description":"Sample events keeping only 0.1% of the events to allow groupby to find the most common hosts without hitting the groupby-limit","value":"sample(percentage=0.1) | groupby(host) | sort()"}],"description":"Samples the event stream. Events that do not have the field being sampled are discarded","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"The names of the field to use for sampling events.","isUnnamed":false,"type":"string","defaultValue":"@timestamp"},{"name":"percentage","isRequired":false,"description":"Keep this percentage of the events.","isUnnamed":true,"type":"number","defaultValue":"1"}],"defaultParameter":"percentage"},{"aliases":[],"name":"eval","examples":[{"description":"Get response size in KB","value":"eval(responsesize = responsesize / 1024)"},{"description":"Add fields together","value":"eval(c = a + b)"},{"description":"Match a field to the timespan. Count should be per minute (not 5 minutes as the bucket span is)","value":"timechart(method, span=5min) | eval(_count=_count/5)"}],"description":"Creates a new field by evaluating the provided expression.  \nThe eval string must always start with an assignment (f=expr....) The result is stored in a field with that name.    \nIn the expression it is possible to supply names of fields, strings and numbers.  \nThe operators available are `==`, `!=`, as well as `+`, `-`, `*`, and `/`; and parentesized expressions.  \nIn context of an eval expression (unlike filters), identifiers *always* denote field values, so  e.g.\n`eval( is_warning= (loglevel==WARN) )` is most likely wrong; you want to write `(loglevel==\"WARN\")`.  \nThe order of evaluation of arguments is left to right.\n","isAggregateFunction":false,"parameters":[],"defaultParameter":null},{"aliases":[],"name":"cidr","examples":[{"description":"match events for which the 'ipAddress' attributes is in the ip range 77.243.48.0/20","value":"cidr(ipAddress, subnet=\"77.243.48.0/20\")"},{"description":"match events for which the 'ipAddress' attributes is in the ip range 77.243.48.0/20 or 256.0.0.0/16","value":"cidr(ipAddress, subnet=[\"77.243.48.0/20\", \"256.0.0.0/16\"])"}],"description":"Filter events using CIDR subnets\n\n      ","isAggregateFunction":false,"parameters":[{"name":"subnet","isRequired":true,"description":"Specifies a CIDR subnet to filter on.","isUnnamed":false,"type":"[string]","defaultValue":null},{"name":"field","isRequired":true,"description":"Specifies the field to run the CIDR expression against.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"negate","isRequired":false,"description":"Only let addresses not in the given subnet pass though. (Also let events without the assigned field pass thru.)","isUnnamed":false,"type":"bool","defaultValue":"false"}],"defaultParameter":"field"},{"aliases":["shannon_entropy"],"name":"shannonEntropy","examples":[{"description":"Shows how to calculate a shannon entropy value for the string in a field.\nAn input event with the field \"dns_name\" with the value \"example.com\" results in the field \"entropy\" having the rounded value 3.095795.\n","value":"entropy := shannonEntropy(dns_name)"}],"description":"Calculates a entropy measure from a string of characters.\n","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The name of the input field.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"The output name of the field to set","isUnnamed":false,"type":"string","defaultValue":"_shannonentropy"}],"defaultParameter":"field"},{"aliases":[],"name":"timeChart","examples":[{"description":"Show the number of different http methods over time.<br/>This is done by dividing events into time buckets of 1 minute. Count the http methods (GET, POST, PUT etc). The timechart will have a line for each http method","value":"timechart(span=1min, series=method, function=count())"},{"description":"Show the number of different http methods over time.<br/>This is done by dividing events into time buckets of 1 minute. Count the http methods (GET, POST, PUT etc). The timechart will have a line for each http method","value":"timechart(buckets=1000, series=method, function=count())"},{"description":"Graph response time percentiles","value":"timechart(function=percentile(field=responsetime, percentiles=[50, 75, 90, 99, 99.9]))"},{"description":"We use coda hale metrics to print rates of various events once per minute.  Such lines include 1-minute average rates \"m1=N\" where N is some number. This example displays all such meters, converting the rates from events/sec to Ki/day. ","value":"type=METER rate_unit=events/second | timechart(name, function=avg(m1), unit=\"events/sec to Ki/day\", span=5m)"},{"description":"Upon completion of every humio request, we issue a log entry which (among other things) prints the size=N of the result. When summing such size's you would need to be aware of the span, but using a unit conversion, we can display the number in Mbytes/hour, and the graph will be agnostic to the span.","value":"timechart(function=sum(size), unit=\"bytes/bucket to Mbytes/hour\", span=30m)"}],"description":"Draw a linechart where the x-axis is time. Time is grouped into buckets","isAggregateFunction":true,"parameters":[{"name":"limit","isRequired":false,"description":"Defines the maximum number of series to produce (defaults to 20). A warning is produced if this limit is exceeded, unless the parameter is specified explicitly.","isUnnamed":false,"type":"number","defaultValue":null},{"name":"span","isRequired":false,"description":"Defines the time span for each bucket. The time span is defined as a [relative time modifier](https://docs.humio.com/appendix/relative-time-syntax) like 1hour or \"3 weeks\". If not provided the search time interval is divided into 127 buckets","isUnnamed":false,"type":"string","defaultValue":null},{"name":"buckets","isRequired":false,"description":"Defines the the number of buckets. The time span is defined by splitting the query time interval into this many buckets. 0..1500","isUnnamed":false,"type":"number","defaultValue":null},{"name":"timezone","isRequired":false,"description":"Defines the time span for each bucket. The time span is defined as a [relative time modifier](https://docs.humio.com/appendix/relative-time-syntax) like 1hour or \"3 weeks\". If not provided the search time interval is divided into 127 buckets","isUnnamed":false,"type":"string","defaultValue":null},{"name":"series","isRequired":false,"description":"Each value in the field specified by this parameter becomes a series on the graph","isUnnamed":true,"type":"string","defaultValue":null},{"name":"unit","isRequired":false,"description":"EXPERIMENTAL FEATURE.  Each value is a unit conversion for the given column.  For instance: \"bytes/span to Kbytes/day\" converts a sum of bytes into Kb/day automatically taking the time span into account. If present, this array must be either length 1 (apply to all series) or have the same length as the function parameter.  Default is no conversion.  The documentation has a section on this [conversion](/rate-unit-conversion-timechart.md)","isUnnamed":false,"type":"[string]","defaultValue":null},{"name":"function","isRequired":false,"description":"Specifies which aggregate functions to perform on each group. Default is to count(as=_count) the elements in each group","isUnnamed":false,"type":"[Aggregate]","defaultValue":"count(as=_count)"}],"defaultParameter":"series"},{"aliases":[],"name":"top","examples":[{"description":"Find top ten users in the logs and show their count","value":"top(user)"},{"description":"Find top 20 ip addresses requesting most bytes from webserver","value":"top(field=client, sum=bytes_sent, limit=20, as=bytes)"}],"description":"Find the most common values of a field.\nIt is also possible to find the occurrences of a field using the value of another field.\n\n\nThis function is implemented using a streaming approximation algorithm when the data set becomes huge.\nIt is implemented using [datasketches](https://datasketches.github.io/docs/FrequentItems/FrequentItemsOverview.html).\nBy default a warning is issued if the result's precision is worse than 5 percent. This can be specified using the error parameter\nThe implementation uses a `maxMapSize` with value 32768. Details about the precision is found [here](https://datasketches.github.io/docs/FrequentItems/FrequentItemsErrorTable.html).\nOnly results falling within the threshold is returned.\n      ","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":true,"description":"The field to group by count.  If field is not present, the event is not counted.  The `top` function works like `groupby(*field*, function=count()) | sort(_count)`","isUnnamed":true,"type":"string","defaultValue":null},{"name":"sum","isRequired":false,"description":"Change semantics from counting to summing the value of a *sum* field. If specified, the `top` works like `groupby(*field*, function=sum(*sum*)) | sort(_sum)`","isUnnamed":false,"type":"string","defaultValue":null},{"name":"limit","isRequired":false,"description":"The number of results to return","isUnnamed":false,"type":"number","defaultValue":"10"},{"name":"as","isRequired":false,"description":"The name of the count field created by top.  Defaults to `_count`, but changed to `_sum` if the `sum` parameter is used.","isUnnamed":false,"type":"string","defaultValue":null},{"name":"rest","isRequired":false,"description":"A row is returned holding the count of all the other values not in top","isUnnamed":false,"type":"string","defaultValue":null},{"name":"percent","isRequired":false,"description":"If set to `true`, add a column named `percent` containing the count in percentage of the total","isUnnamed":false,"type":"bool","defaultValue":"false"},{"name":"error","isRequired":false,"description":"Show a warning if the result is not precise enough. This parameter specifies the error treshold in percent. Default is 5 percent","isUnnamed":false,"type":"number","defaultValue":"5"}],"defaultParameter":"field"},{"aliases":[],"name":"table","examples":[{"description":"Look at HTTP GET methods and create a table with the fields statuscode and responsetime","value":"method=GET | table([statuscode, responsetime])"},{"description":"Show the name and responsetime of the 50 slowest requests","value":"table([name, responsetime], sortby=respsonetime, reverse=true)"}],"description":"Represent the data as a table. Specify a list of `fields` to select. Columns in the table are sorted in the specified field  order. \nThis is an aggregate function and it will limit the number of events returned Using the limit parameter.\nIt is possible to specify how the table is sorted. Using sort, this function can be used find the 100 events with the highest reponsetimes etc. \n       ","isAggregateFunction":true,"parameters":[{"name":"fields","isRequired":true,"description":"The names of the fields to select.","isUnnamed":true,"type":"[string]","defaultValue":null},{"name":"sortby","isRequired":false,"description":"Fields to sort by","isUnnamed":false,"type":"[string]","defaultValue":"@timestamp"},{"name":"type","isRequired":false,"description":"type of the field we sort. Can be any, string, number, or hex. When set to any, sort tries to detect the type from the first value it finds for each field. If the value matches regex /-?0[xX]/ then hex is selected.","isUnnamed":false,"type":"string","defaultValue":"any"},{"name":"reverse","isRequired":false,"description":"should sorting be reversed (i.e., descending)","isUnnamed":false,"type":"bool","defaultValue":null},{"name":"order","isRequired":false,"description":"sorting (ascending or descending). descending is default","isUnnamed":false,"type":"string","defaultValue":null},{"name":"limit","isRequired":false,"description":"limit result size. If no limit is specified a default limit of 200 is used","isUnnamed":false,"type":"number","defaultValue":null}],"defaultParameter":"fields"},{"aliases":[],"name":"rdns","examples":[{"description":"Resolve ipAddress (if present) using the server 8.8.8.8, and store the resulting DNS name in 'dnsName'","value":"rdns(ipAddress, server=\"8.8.8.8\", as=dnsName)"},{"description":"Resolve ipAddress (if present) and store the resulting DNS name in 'hostname'","value":"rdns(ipAddress)"}],"description":" events using RDNS lookup.\n\n      ","isAggregateFunction":true,"parameters":[{"name":"server","isRequired":false,"description":"Specifies a DNS server address.","isUnnamed":false,"type":"string","defaultValue":null},{"name":"field","isRequired":true,"description":"Specifies the field to run the RDNS lookup against.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"Specifies the field into which the resolved value is stored.","isUnnamed":false,"type":"string","defaultValue":"hostname"}],"defaultParameter":"field"},{"aliases":[],"name":"length","examples":[{"description":"The number of characters in the @rawstring field","value":"length(@rawstring)"},{"description":"The number of characters in the @rawstring field, putting it in the field rawLength","value":"length(@rawstring, as=\"rawLength\")"}],"description":"Returns the number of characters in a string field.","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":true,"description":"The name of the input field to length.","isUnnamed":true,"type":"string","defaultValue":null},{"name":"as","isRequired":false,"description":"name of output field","isUnnamed":false,"type":"string","defaultValue":"_length"}],"defaultParameter":"field"},{"aliases":[],"name":"sort","examples":[{"description":"Count the different http status codes for a webserver and sort them descending by their count","value":"groupby(field=statuscode, function=count()) | sort(field=_count, type=number, order=desc)"},{"description":"Find the 50 slowest request from service A","value":"service=my-service-a | sort(responsetime, reverse=true)"},{"description":"Sort all results by statuscode, then by response_size within each status_code","value":"#type=accesslog | sort([statuscode, response_size])"}],"description":"Sort events by a field.<br/>Setting the type field tells sort how to compare the individual values, either using lexicographical order (strings) or numerical magnitude (number, hex). The default type=any will make sort try to detect the type by looking at the values. type=hex support numbers as strings starting with either \"0x\" , \"0X\" or no prefix.<br/>Warning: sorting is done in memory - so do not sort huge amounts of events. This is typicaly not a problem if the result has been aggregated. Typically sort is put last in the query after an aggregating function.","isAggregateFunction":true,"parameters":[{"name":"field","isRequired":false,"description":"Fields to sort by","isUnnamed":true,"type":"[string]","defaultValue":"_count"},{"name":"type","isRequired":false,"description":"type of the field we sort. Can be any, string, number, or hex. When set to any, sort tries to detect the type from the first value it finds for each field. If the value matches regex /-?0[xX]/ then hex is selected.","isUnnamed":false,"type":"string","defaultValue":"any"},{"name":"reverse","isRequired":false,"description":"should sorting be reversed (i.e., descending)","isUnnamed":false,"type":"bool","defaultValue":null},{"name":"order","isRequired":false,"description":"sorting (ascending or descending). descending is default","isUnnamed":false,"type":"string","defaultValue":null},{"name":"limit","isRequired":false,"description":"limit result size. If no limit is specified a default limit of 200 is used","isUnnamed":false,"type":"number","defaultValue":null}],"defaultParameter":"field"},{"aliases":[],"name":"session","examples":[{"description":"Count unique visitors (each visitor defined as non-active for 15 minutes)","value":"groupby(client_ip, function=session(maxpause=15m)) | count()"},{"description":"Find the visits with most clicks","value":"groupby(cookie_id, function=session(maxpause=15m, count(as=clicks))) | sort(clicks)"}],"description":"Collects events into sessions, which are series of events that are no further than `maxpause` apart (defaults to 15m),\n and then performs an aggregate function across the events that make up the session.\n      ","isAggregateFunction":true,"parameters":[{"name":"maxpause","isRequired":false,"description":"defines the maximum pause between sessions i.e., events more than this far apart will become seaparate sessions.  Defaults to 15m","isUnnamed":false,"type":"string","defaultValue":"15m"},{"name":"function","isRequired":false,"description":"Specifies which aggregate functions to perform on each session. Default is to count(as=_count) the elements in each group","isUnnamed":true,"type":"[Aggregate]","defaultValue":"count(as=_count)"}],"defaultParameter":"function"},{"aliases":[],"name":"parseJson","examples":[{"description":"If the whole event send to Humio is JSON like `{\"service\": \"userService\", \"timestamp\": \"2017-12-18T20:39:35Z\", \"msg\": \"user with id=47 logged in\"}`","value":"parseJson() | parseTimestamp(field=timestamp)"},{"description":"If a field in the incoming event contains JSON like `2017-12-18T20:39:35Z user id=47 logged in details=\"{\"name\": \"Peter\", \"email\": \"peter@test.com\", \"id\":47}\"`\\n\\n\nIn the example below the details field is extracted using the `kvparse` function and then `parseJson` is used to parse the JSON inside the details field. \n          ","value":"/(?<timestamp>\\S+)/ | parseTimestamp() | kvParse() | parseJson(field=details)"},{"description":"It is possible to prefix names of the extracted JSON fields. \nThis can be useful for avoiding collisons with existing fields with the same name. \nFor example the input line `added new user details=\"{\"email\": \"foo@test.com\", \"name\": \"Peter\"}`\nCould be parsed into these fields: `user.email=foo@test.com`, `user.name=Peter`.\n        ","value":"kvParse() | parseJson(field=details, prefix=\"user.\")"}],"description":"\nParse data as JSON. The specified fields will be parsed as JSON. Specify `field=@rawstring` to parse the rawstring into JSON.\n It is possible to prefix the names of the extracted fields using the `prefix` parameter\n \n    ","isAggregateFunction":false,"parameters":[{"name":"field","isRequired":false,"description":"Fields that should be parsed as JSON","isUnnamed":true,"type":"[string]","defaultValue":"@rawstring"},{"name":"prefix","isRequired":false,"description":"Prefix the name of the extracted JSON fields with the value of this parameter","isUnnamed":false,"type":"string","defaultValue":""}],"defaultParameter":"field"}]